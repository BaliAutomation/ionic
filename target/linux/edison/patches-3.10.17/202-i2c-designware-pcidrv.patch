diff --git a/drivers/i2c/busses/i2c-designware-pcidrv.c b/drivers/i2c/busses/i2c-designware-pcidrv.c
index f6ed06c..b150bc2 100644
--- a/drivers/i2c/busses/i2c-designware-pcidrv.c
+++ b/drivers/i2c/busses/i2c-designware-pcidrv.c
@@ -39,113 +39,32 @@
 #include <linux/slab.h>
 #include <linux/pci.h>
 #include <linux/pm_runtime.h>
+#include <linux/semaphore.h>
+#include <linux/fs.h>
+#include <linux/acpi.h>
 #include "i2c-designware-core.h"
 
 #define DRIVER_NAME "i2c-designware-pci"
+#define DW_I2C_STATIC_BUS_NUM	10
 
-enum dw_pci_ctl_id_t {
-	moorestown_0,
-	moorestown_1,
-	moorestown_2,
-
-	medfield_0,
-	medfield_1,
-	medfield_2,
-	medfield_3,
-	medfield_4,
-	medfield_5,
-};
+static int i2c_dw_pci_suspend(struct device *dev)
+{
+	struct pci_dev *pdev = container_of(dev, struct pci_dev, dev);
+	struct dw_i2c_dev *i2c = pci_get_drvdata(pdev);
 
-struct dw_pci_controller {
-	u32 bus_num;
-	u32 bus_cfg;
-	u32 tx_fifo_depth;
-	u32 rx_fifo_depth;
-	u32 clk_khz;
-};
+	dev_dbg(dev, "suspend called\n");
 
-#define INTEL_MID_STD_CFG  (DW_IC_CON_MASTER |			\
-				DW_IC_CON_SLAVE_DISABLE |	\
-				DW_IC_CON_RESTART_EN)
-
-static struct  dw_pci_controller  dw_pci_controllers[] = {
-	[moorestown_0] = {
-		.bus_num     = 0,
-		.bus_cfg   = INTEL_MID_STD_CFG | DW_IC_CON_SPEED_FAST,
-		.tx_fifo_depth = 32,
-		.rx_fifo_depth = 32,
-		.clk_khz      = 25000,
-	},
-	[moorestown_1] = {
-		.bus_num     = 1,
-		.bus_cfg   = INTEL_MID_STD_CFG | DW_IC_CON_SPEED_FAST,
-		.tx_fifo_depth = 32,
-		.rx_fifo_depth = 32,
-		.clk_khz      = 25000,
-	},
-	[moorestown_2] = {
-		.bus_num     = 2,
-		.bus_cfg   = INTEL_MID_STD_CFG | DW_IC_CON_SPEED_FAST,
-		.tx_fifo_depth = 32,
-		.rx_fifo_depth = 32,
-		.clk_khz      = 25000,
-	},
-	[medfield_0] = {
-		.bus_num     = 0,
-		.bus_cfg   = INTEL_MID_STD_CFG | DW_IC_CON_SPEED_FAST,
-		.tx_fifo_depth = 32,
-		.rx_fifo_depth = 32,
-		.clk_khz      = 25000,
-	},
-	[medfield_1] = {
-		.bus_num     = 1,
-		.bus_cfg   = INTEL_MID_STD_CFG | DW_IC_CON_SPEED_FAST,
-		.tx_fifo_depth = 32,
-		.rx_fifo_depth = 32,
-		.clk_khz      = 25000,
-	},
-	[medfield_2] = {
-		.bus_num     = 2,
-		.bus_cfg   = INTEL_MID_STD_CFG | DW_IC_CON_SPEED_FAST,
-		.tx_fifo_depth = 32,
-		.rx_fifo_depth = 32,
-		.clk_khz      = 25000,
-	},
-	[medfield_3] = {
-		.bus_num     = 3,
-		.bus_cfg   = INTEL_MID_STD_CFG | DW_IC_CON_SPEED_STD,
-		.tx_fifo_depth = 32,
-		.rx_fifo_depth = 32,
-		.clk_khz      = 25000,
-	},
-	[medfield_4] = {
-		.bus_num     = 4,
-		.bus_cfg   = INTEL_MID_STD_CFG | DW_IC_CON_SPEED_FAST,
-		.tx_fifo_depth = 32,
-		.rx_fifo_depth = 32,
-		.clk_khz      = 25000,
-	},
-	[medfield_5] = {
-		.bus_num     = 5,
-		.bus_cfg   = INTEL_MID_STD_CFG | DW_IC_CON_SPEED_FAST,
-		.tx_fifo_depth = 32,
-		.rx_fifo_depth = 32,
-		.clk_khz      = 25000,
-	},
-};
-static struct i2c_algorithm i2c_dw_algo = {
-	.master_xfer	= i2c_dw_xfer,
-	.functionality	= i2c_dw_func,
-};
+	return i2c_dw_suspend(i2c, false);
+}
 
-static int i2c_dw_pci_suspend(struct device *dev)
+static int i2c_dw_pci_runtime_suspend(struct device *dev)
 {
 	struct pci_dev *pdev = container_of(dev, struct pci_dev, dev);
 	struct dw_i2c_dev *i2c = pci_get_drvdata(pdev);
 	int err;
 
-
-	i2c_dw_disable(i2c);
+	dev_dbg(dev, "runtime suspend called\n");
+	i2c_dw_suspend(i2c, true);
 
 	err = pci_save_state(pdev);
 	if (err) {
@@ -166,130 +85,86 @@ static int i2c_dw_pci_resume(struct device *dev)
 {
 	struct pci_dev *pdev = container_of(dev, struct pci_dev, dev);
 	struct dw_i2c_dev *i2c = pci_get_drvdata(pdev);
-	int err;
-	u32 enabled;
 
-	enabled = i2c_dw_is_enabled(i2c);
-	if (enabled)
-		return 0;
+	dev_dbg(dev, "resume called\n");
+	return i2c_dw_resume(i2c, false);
+}
+
+static int i2c_dw_pci_runtime_resume(struct device *dev)
+{
+	struct pci_dev *pdev = container_of(dev, struct pci_dev, dev);
+	struct dw_i2c_dev *i2c = pci_get_drvdata(pdev);
+	int err;
 
+	dev_dbg(dev, "runtime resume called\n");
 	err = pci_set_power_state(pdev, PCI_D0);
 	if (err) {
 		dev_err(&pdev->dev, "pci_set_power_state() failed\n");
 		return err;
 	}
-
 	pci_restore_state(pdev);
+	i2c_dw_resume(i2c, true);
 
-	i2c_dw_init(i2c);
 	return 0;
 }
 
-static int i2c_dw_pci_runtime_idle(struct device *dev)
-{
-	int err = pm_schedule_suspend(dev, 500);
-	dev_dbg(dev, "runtime_idle called\n");
-
-	if (err != 0)
-		return 0;
-	return -EBUSY;
-}
-
 static const struct dev_pm_ops i2c_dw_pm_ops = {
-	.resume         = i2c_dw_pci_resume,
-	.suspend        = i2c_dw_pci_suspend,
-	SET_RUNTIME_PM_OPS(i2c_dw_pci_suspend, i2c_dw_pci_resume,
-			   i2c_dw_pci_runtime_idle)
+	.suspend_late = i2c_dw_pci_suspend,
+	.resume_early = i2c_dw_pci_resume,
+	SET_RUNTIME_PM_OPS(i2c_dw_pci_runtime_suspend,
+			   i2c_dw_pci_runtime_resume,
+			   NULL)
 };
 
-static u32 i2c_dw_get_clk_rate_khz(struct dw_i2c_dev *dev)
-{
-	return dev->controller->clk_khz;
-}
-
 static int i2c_dw_pci_probe(struct pci_dev *pdev,
-			    const struct pci_device_id *id)
+const struct pci_device_id *id)
 {
 	struct dw_i2c_dev *dev;
-	struct i2c_adapter *adap;
+	unsigned long start, len;
 	int r;
-	struct  dw_pci_controller *controller;
-
-	if (id->driver_data >= ARRAY_SIZE(dw_pci_controllers)) {
-		dev_err(&pdev->dev, "%s: invalid driver data %ld\n", __func__,
-			id->driver_data);
-		return -EINVAL;
-	}
+	int bus_idx;
+	static int bus_num;
 
-	controller = &dw_pci_controllers[id->driver_data];
+	bus_idx = id->driver_data + bus_num;
+	bus_num++;
 
-	r = pcim_enable_device(pdev);
+	r = pci_enable_device(pdev);
 	if (r) {
 		dev_err(&pdev->dev, "Failed to enable I2C PCI device (%d)\n",
 			r);
 		return r;
 	}
 
-	r = pcim_iomap_regions(pdev, 1 << 0, pci_name(pdev));
+	/* Determine the address of the I2C area */
+	start = pci_resource_start(pdev, 0);
+	len = pci_resource_len(pdev, 0);
+	if (!start || len == 0) {
+		dev_err(&pdev->dev, "base address not set\n");
+		return -ENODEV;
+	}
+
+	r = pci_request_region(pdev, 0, DRIVER_NAME);
 	if (r) {
-		dev_err(&pdev->dev, "I/O memory remapping failed\n");
+		dev_err(&pdev->dev, "failed to request I2C region "
+			"0x%lx-0x%lx\n", start,
+			(unsigned long)pci_resource_end(pdev, 0));
 		return r;
 	}
 
-	dev = devm_kzalloc(&pdev->dev, sizeof(struct dw_i2c_dev), GFP_KERNEL);
-	if (!dev)
-		return -ENOMEM;
-
-	init_completion(&dev->cmd_complete);
-	mutex_init(&dev->lock);
-	dev->clk = NULL;
-	dev->controller = controller;
-	dev->get_clk_rate_khz = i2c_dw_get_clk_rate_khz;
-	dev->base = pcim_iomap_table(pdev)[0];
-	dev->dev = &pdev->dev;
-	dev->functionality =
-		I2C_FUNC_I2C |
-		I2C_FUNC_SMBUS_BYTE |
-		I2C_FUNC_SMBUS_BYTE_DATA |
-		I2C_FUNC_SMBUS_WORD_DATA |
-		I2C_FUNC_SMBUS_I2C_BLOCK;
-	dev->master_cfg =  controller->bus_cfg;
+	dev = i2c_dw_setup(&pdev->dev, bus_idx, start, len, pdev->irq);
+	if (IS_ERR(dev)) {
+		pci_release_region(pdev, 0);
+		dev_err(&pdev->dev, "failed to setup i2c\n");
+		return -EINVAL;
+ 	}
 
 	pci_set_drvdata(pdev, dev);
 
-	dev->tx_fifo_depth = controller->tx_fifo_depth;
-	dev->rx_fifo_depth = controller->rx_fifo_depth;
-	r = i2c_dw_init(dev);
-	if (r)
-		return r;
-
-	adap = &dev->adapter;
-	i2c_set_adapdata(adap, dev);
-	adap->owner = THIS_MODULE;
-	adap->class = 0;
-	adap->algo = &i2c_dw_algo;
-	adap->dev.parent = &pdev->dev;
-	adap->nr = controller->bus_num;
-	snprintf(adap->name, sizeof(adap->name), "i2c-designware-pci-%d",
-		adap->nr);
-
-	r = devm_request_irq(&pdev->dev, pdev->irq, i2c_dw_isr, IRQF_SHARED,
-			adap->name, dev);
-	if (r) {
-		dev_err(&pdev->dev, "failure requesting irq %i\n", dev->irq);
-		return r;
-	}
-
-	i2c_dw_disable_int(dev);
-	i2c_dw_clear_int(dev);
-	r = i2c_add_numbered_adapter(adap);
-	if (r) {
-		dev_err(&pdev->dev, "failure adding adapter\n");
-		return r;
-	}
+	i2c_acpi_devices_setup(&pdev->dev, dev);
 
-	pm_runtime_set_autosuspend_delay(&pdev->dev, 1000);
+	pm_runtime_set_autosuspend_delay(&pdev->dev, 50);
 	pm_runtime_use_autosuspend(&pdev->dev);
+	pm_runtime_put_noidle(&pdev->dev);
 	pm_runtime_allow(&pdev->dev);
 
 	return 0;
@@ -299,35 +174,60 @@ static void i2c_dw_pci_remove(struct pci_dev *pdev)
 {
 	struct dw_i2c_dev *dev = pci_get_drvdata(pdev);
 
-	i2c_dw_disable(dev);
 	pm_runtime_forbid(&pdev->dev);
-	pm_runtime_get_noresume(&pdev->dev);
-
-	i2c_del_adapter(&dev->adapter);
+	i2c_dw_free(&pdev->dev, dev);
+	pci_set_drvdata(pdev, NULL);
+	pci_release_region(pdev, 0);
 }
 
 /* work with hotplug and coldplug */
 MODULE_ALIAS("i2c_designware-pci");
 
-static DEFINE_PCI_DEVICE_TABLE(i2_designware_pci_ids) = {
+DEFINE_PCI_DEVICE_TABLE(i2c_designware_pci_ids) = {
 	/* Moorestown */
 	{ PCI_VDEVICE(INTEL, 0x0802), moorestown_0 },
-	{ PCI_VDEVICE(INTEL, 0x0803), moorestown_1 },
-	{ PCI_VDEVICE(INTEL, 0x0804), moorestown_2 },
+	{ PCI_VDEVICE(INTEL, 0x0803), moorestown_0 },
+	{ PCI_VDEVICE(INTEL, 0x0804), moorestown_0 },
 	/* Medfield */
-	{ PCI_VDEVICE(INTEL, 0x0817), medfield_3,},
-	{ PCI_VDEVICE(INTEL, 0x0818), medfield_4 },
-	{ PCI_VDEVICE(INTEL, 0x0819), medfield_5 },
+	{ PCI_VDEVICE(INTEL, 0x0817), medfield_0 },
+	{ PCI_VDEVICE(INTEL, 0x0818), medfield_0 },
+	{ PCI_VDEVICE(INTEL, 0x0819), medfield_0 },
 	{ PCI_VDEVICE(INTEL, 0x082C), medfield_0 },
-	{ PCI_VDEVICE(INTEL, 0x082D), medfield_1 },
-	{ PCI_VDEVICE(INTEL, 0x082E), medfield_2 },
+	{ PCI_VDEVICE(INTEL, 0x082D), medfield_0 },
+	{ PCI_VDEVICE(INTEL, 0x082E), medfield_0 },
+	/* Cloverview */
+	{ PCI_VDEVICE(INTEL, 0x08E2), cloverview_0 },
+	{ PCI_VDEVICE(INTEL, 0x08E3), cloverview_0 },
+	{ PCI_VDEVICE(INTEL, 0x08E4), cloverview_0 },
+	{ PCI_VDEVICE(INTEL, 0x08F4), cloverview_0 },
+	{ PCI_VDEVICE(INTEL, 0x08F5), cloverview_0 },
+	{ PCI_VDEVICE(INTEL, 0x08F6), cloverview_0 },
+	/* Merrifield */
+	{ PCI_VDEVICE(INTEL, 0x1195), merrifield_0 },
+	{ PCI_VDEVICE(INTEL, 0x1196), merrifield_0 },
+	/* Valleyview 2 */
+	{ PCI_VDEVICE(INTEL, 0x0F41), valleyview_0 },
+	{ PCI_VDEVICE(INTEL, 0x0F42), valleyview_0 },
+	{ PCI_VDEVICE(INTEL, 0x0F43), valleyview_0 },
+	{ PCI_VDEVICE(INTEL, 0x0F44), valleyview_0 },
+	{ PCI_VDEVICE(INTEL, 0x0F45), valleyview_0 },
+	{ PCI_VDEVICE(INTEL, 0x0F46), valleyview_0 },
+	{ PCI_VDEVICE(INTEL, 0x0F47), valleyview_0 },
+	/* Cherryview */
+	{ PCI_VDEVICE(INTEL, 0x22C1), cherryview_0 },
+	{ PCI_VDEVICE(INTEL, 0x22C2), cherryview_0 },
+	{ PCI_VDEVICE(INTEL, 0x22C3), cherryview_0 },
+	{ PCI_VDEVICE(INTEL, 0x22C4), cherryview_0 },
+	{ PCI_VDEVICE(INTEL, 0x22C5), cherryview_0 },
+	{ PCI_VDEVICE(INTEL, 0x22C6), cherryview_0 },
+	{ PCI_VDEVICE(INTEL, 0x22C7), cherryview_0 },
 	{ 0,}
 };
-MODULE_DEVICE_TABLE(pci, i2_designware_pci_ids);
+MODULE_DEVICE_TABLE(pci, i2c_designware_pci_ids);
 
 static struct pci_driver dw_i2c_driver = {
 	.name		= DRIVER_NAME,
-	.id_table	= i2_designware_pci_ids,
+	.id_table	= i2c_designware_pci_ids,
 	.probe		= i2c_dw_pci_probe,
 	.remove		= i2c_dw_pci_remove,
 	.driver         = {
@@ -335,7 +235,38 @@ static struct pci_driver dw_i2c_driver = {
 	},
 };
 
-module_pci_driver(dw_i2c_driver);
+static int __init dw_i2c_init_driver(void)
+{
+	return  pci_register_driver(&dw_i2c_driver);
+}
+module_init(dw_i2c_init_driver);
+
+static void __exit dw_i2c_exit_driver(void)
+{
+	pci_unregister_driver(&dw_i2c_driver);
+}
+module_exit(dw_i2c_exit_driver);
+
+#ifndef MODULE
+static int __init dw_i2c_reserve_static_bus(void)
+{
+	struct i2c_board_info dummy = {
+		I2C_BOARD_INFO("dummy", 0xff),
+	};
+
+	i2c_register_board_info(DW_I2C_STATIC_BUS_NUM, &dummy, 1);
+	return 0;
+}
+subsys_initcall(dw_i2c_reserve_static_bus);
+
+static void dw_i2c_pci_final_quirks(struct pci_dev *pdev)
+{
+	pdev->pm_cap = 0x80;
+}
+
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x0F44,
+				dw_i2c_pci_final_quirks);
+#endif
 
 MODULE_AUTHOR("Baruch Siach <baruch@tkos.co.il>");
 MODULE_DESCRIPTION("Synopsys DesignWare PCI I2C bus adapter");
